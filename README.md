# MEDYANSimRunner.jl
Manage long running MEDYAN.jl simulations

Simulations run using code stored in the `input` directory and write outputs to `output` directory.

## `input` directory

The input directory must contain a `main.jl` file, a `Manifest.toml`, a `Project.toml`, and a `Job.toml`.

The input directory will be the working directory of the simulation and can include other data needed for the simulation, including an `Artifacts.toml`

The input directory should not be mutated during or after a simulation.

### `main.jl` file

This file contains the julia functions used when running the simulation.
These functions can modify any input state variables, but in general should return the state.
These functions can also use the default random number generator, this will automatically saved and loaded.

#### Standard input parameters.
 - `step::Int`: starts out at 0 after setup and is auto incremented right after every loop.

#### `setup(job_idx::Int) -> header_dict, state`
Return the header dictionary to be written as the `header.json` file in output.
Also return the state that gets passed on to `loop` and the state that gets passed to `save_snapshot` and `load_snapshot`.
Also set the default random number generator seed.

`job_idx::Int`: The job index starting with job 1. This is used for multi job simulations.

#### `save_snapshot(step::Int, hdf5_group::Union{HDF5.Group, HDF5.File}, state)`
Save the state in the empty `hdf5_group`.
This function should not mutate `state`

#### `load_snapshot(step::Int, hdf5_group::Union{HDF5.Group, HDF5.File}, state) -> state`
Load the state saved by `save_snapshot` `hdf5_group`
This function can mutate `state`.
`state` may be the state returned from `setup` or the `state` returned by `loop`.

#### `done(step::Int, state) -> done::Bool, expected_final_step::Int`
Return true if the simulation is done, or false if `loop` should be called again.

Also return the expected value of step when done will first be true, used for displaying the simulation progress.

This function should not mutate `state`

#### `loop(step::Int, state) -> state`
Return the state that get passed to `save_snapshot`



### `Manifest.toml` and `Project.toml`

These contain the julia environment used when running the simulation. These must contain HDF5 and JSON3, because these are required for saving data.

### Main loop pseudo code

```
activate and instantiate the environment
include("main.jl")
create output directory if it doesn't exist
header, state =  setup(job_idx)
save header
step = 0
file = create snapshot file(step)
save_snapshot(step, file, state)
while true
    state = load_snapshot(step, file, state)
    close(file)
    state = loop(step, state)
    step = step + 1
    file = create snapshot file(step)
    save_snapshot(step, file, state)
    if done(step::Int, state)
        break
    end
end
```
### `Job.toml`

This file contains options for configuring the simulation runner.

- `version`: `1.0` the `Job.toml` version.

- `step_timeout`: the maximum amount of time in seconds each step is allowed to take before the job is killed.

- `max_steps`: the maximum number of steps a job is allowed to take before the job is killed.

- `startup_timeout`: the maximum amount of time in seconds to load everything and run the first loop.

- `max_snapshot_MB`: the maximum amount of hard drive space each snapshot is allowed to use in megabytes.


## `output` directory

The output directory has an `out$N` subdirectory for parallel job N's output.

Each out subdirectory has the following files.

### `logs.txt`
Any logs, warnings, and errors generated by the simulation are saved in this file.

### `warnings.txt`
Any warnings, and errors generated by the simulation are saved in this file.

### `errors.txt`
Any errors generated by the simulation are saved in this file.

### `header.json`
A description of the system.

### `info.txt`
Data describing the saved snapshots, and if the simulation is done or errored, or needs to be continued.

The last element in each line is the sha256 of the line, not including the last comma space, and hash value.


The first line is.
```
version = 1.0, job_idx = 1, input_git_tree_sha1 = 5a936e..., 54bf8d69288...
```
- `version`: version of the info.txt format.
- `job_idx`: index of the job. 
- `input_git_tree_sha1`: hash of input directory

The second line is:
```
header_sha256 = 2cf934..., 312f788...
```
- `header_sha256`: hash of header.json.
Or:
```
Error starting job, 8d69288...
```

After these lines each of the next lines correspond to a saved snapshot.

These have the format:
```
yyyy-mm-dd HH:MM:SS, step number, nthreads, julia versioninfo, rng state, snapshot sha256, line sha256
```

The final line explains how the simulation ended it can be one of the following:
```
Error starting job, line sha256
```

```
Error running job, line sha256
```

```
Error startup_timeout reached, line sha256
```

```
Error step_timeout reached, line sha256
```

```
Error max_steps reached, line sha256
```

```
Error max_snapshot_bytes reached, line sha256
```

```
Done, line sha256
```

See the log files for more details and error messages.


### `snapshots` subdirectory
Contains `snapshot$i.h5` files where `i` is the step of the simulation.
The states returned by `setup` are stored in `snapshot0.h5`
